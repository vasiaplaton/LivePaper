Path: ./chatgpt
Contents:
Path: ./chatgpt
Contents:

--------------------------------------------------
Path: ./test/java/ru/vsu/cs/platon/docs/DocsApplicationTests.java
Contents:
package ru.vsu.cs.platon.docs;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class DocsApplicationTests {

	@Test
	void contextLoads() {
	}

}

--------------------------------------------------
Path: ./main/resources/application.properties
Contents:
spring.application.name=Docs
spring.datasource.url=${DATABASE_URL:jdbc:postgresql://localhost:5478/db}
spring.datasource.username=${POSTGRES_USER:admin}
spring.datasource.password=${POSTGRES_PASSWORD:1q2w3e4r}
spring.datasource.driver-class-name=org.postgresql.Driver

# JPA settings
spring.jpa.hibernate.ddl-auto=update
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
# logging.level.org.springframework.security=DEBUG
# logging.level.org.springframework.security.web.access=DEBUG
spring.flyway.enabled=true
spring.flyway.locations=classpath:db/migration

springdoc.api-docs.path=/openapi.json
springdoc.swagger-ui.path=/docs

jwt.secret=superSecretJwtKey1234567890superSecretJwtKey1234567890superSecretJwtKey1234567890
spring.security.user.name=admin
spring.security.user.password=your_secure_password

--------------------------------------------------
Path: ./main/resources/db/migration/V3__create_documents.sql
Contents:
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

CREATE TABLE documents (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    title VARCHAR(255) NOT NULL,
    file_path TEXT NOT NULL, -- Путь к зашифрованному файлу с документом (md)
    owner_id INT NOT NULL,   -- Владелец документа
    access_level VARCHAR(50) NULL DEFAULT 'PRIVATE', -- PRIVATE, READ_ONLY, EDITABLE
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT fk_owner FOREIGN KEY (owner_id) REFERENCES users(id) ON DELETE CASCADE
);

CREATE TABLE document_permissions (
    id SERIAL PRIMARY KEY,
    document_id UUID NOT NULL,
    user_id INT NOT NULL,
    role VARCHAR(50) NOT NULL, -- READER, EDITOR
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT fk_document FOREIGN KEY (document_id) REFERENCES documents(id) ON DELETE CASCADE,
    CONSTRAINT fk_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    UNIQUE (document_id, user_id)
);

CREATE TABLE document_files (
    id SERIAL PRIMARY KEY,
    document_id UUID NOT NULL,
    file_path TEXT NOT NULL, -- Путь к файлу (изображение, вложение)
    encrypted BOOLEAN DEFAULT TRUE, -- Файл зашифрован?
    uploaded_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT fk_document FOREIGN KEY (document_id) REFERENCES documents(id) ON DELETE CASCADE
);

--------------------------------------------------
Path: ./main/resources/db/migration/V1__create_users_table.sql
Contents:
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    email VARCHAR(255) NOT NULL UNIQUE,
    password_hash VARCHAR(255) NOT NULL,
    username VARCHAR(255) NOT NULL,
    role VARCHAR(50),
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

--------------------------------------------------
Path: ./main/resources/db/migration/V2__create_refresh_tokens_table.sql
Contents:
CREATE TABLE refresh_tokens (
    id SERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL,
    token VARCHAR(512) NOT NULL UNIQUE,
    expiry_date TIMESTAMP NOT NULL,
    ip_address VARCHAR(45),  -- IPv4 и IPv6 адреса
    user_agent TEXT,         -- Информация о браузере/устройстве
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT fk_user FOREIGN KEY(user_id) REFERENCES users(id) ON DELETE CASCADE
);

--------------------------------------------------
Path: ./main/java/ru/vsu/cs/platon/docs/DocsApplication.java
Contents:
package ru.vsu.cs.platon.docs;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@SpringBootApplication
@RestController
public class DocsApplication {

	public static void main(String[] args) {
		SpringApplication.run(DocsApplication.class, args);
	}

	@GetMapping("/hello")
	public String hello(@RequestParam(value = "name", defaultValue = "World") String name) {
		return String.format("Hello %s!", name);
	}
}

--------------------------------------------------
Path: ./main/java/ru/vsu/cs/platon/docs/dto/ShareDocumentRequestDTO.java
Contents:
package ru.vsu.cs.platon.docs.dto;

import lombok.Data;
import ru.vsu.cs.platon.docs.model.DocumentRole;

@Data
public class ShareDocumentRequestDTO {
    private String email;
    private DocumentRole role;
}

--------------------------------------------------
Path: ./main/java/ru/vsu/cs/platon/docs/dto/DocumentPermissionDTO.java
Contents:
package ru.vsu.cs.platon.docs.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import ru.vsu.cs.platon.docs.model.DocumentRole;

@Data
@AllArgsConstructor
public class DocumentPermissionDTO {
    private Long id;
    private Long userId;
    private String username;
    private DocumentRole role;
}

--------------------------------------------------
Path: ./main/java/ru/vsu/cs/platon/docs/dto/CreateDocumentRequestDTO.java
Contents:
package ru.vsu.cs.platon.docs.dto;

import lombok.Data;

@Data
public class CreateDocumentRequestDTO {
    private String title;
}

--------------------------------------------------
Path: ./main/java/ru/vsu/cs/platon/docs/dto/UserDTO.java
Contents:
package ru.vsu.cs.platon.docs.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import ru.vsu.cs.platon.docs.model.UserRole;

import java.util.List;

@Data
@AllArgsConstructor
public class UserDTO {
    private Long id;
    private String email;
    private String username;
    private UserRole role;
    private List<DocumentDTO> documents;
}

--------------------------------------------------
Path: ./main/java/ru/vsu/cs/platon/docs/dto/UpdateDocumentRequestDTO.java
Contents:
package ru.vsu.cs.platon.docs.dto;

import lombok.Data;
import ru.vsu.cs.platon.docs.model.DocumentAccessLevel;

@Data
public class UpdateDocumentRequestDTO {
    private String title;
    private DocumentAccessLevel accessLevel;
}

--------------------------------------------------
Path: ./main/java/ru/vsu/cs/platon/docs/dto/DocumentDTO.java
Contents:
package ru.vsu.cs.platon.docs.dto;

import lombok.AllArgsConstructor;
import lombok.Data;

import java.util.UUID;

@Data
@AllArgsConstructor
public class DocumentDTO {
    private UUID id;
    private String title;
    private String createdAt;
}

--------------------------------------------------
Path: ./main/java/ru/vsu/cs/platon/docs/dto/auth/RegisterRequestDTO.java
Contents:
package ru.vsu.cs.platon.docs.dto.auth;

import lombok.Data;

@Data
public class RegisterRequestDTO {
    private String email;
    private String password;
    private String username;
}

--------------------------------------------------
Path: ./main/java/ru/vsu/cs/platon/docs/dto/auth/AuthResponseDTO.java
Contents:
package ru.vsu.cs.platon.docs.dto.auth;

import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class AuthResponseDTO {
    private String accessToken;
    private String refreshToken;
}

--------------------------------------------------
Path: ./main/java/ru/vsu/cs/platon/docs/dto/auth/LoginRequestDTO.java
Contents:
package ru.vsu.cs.platon.docs.dto.auth;

import lombok.Data;

@Data
public class LoginRequestDTO {
    private String email;
    private String password;
}

--------------------------------------------------
Path: ./main/java/ru/vsu/cs/platon/docs/dto/auth/RefreshRequestDTO.java
Contents:
package ru.vsu.cs.platon.docs.dto.auth;

import lombok.Data;

@Data
public class RefreshRequestDTO {
    private String refreshToken;
}

--------------------------------------------------
Path: ./main/java/ru/vsu/cs/platon/docs/repository/DocumentRepository.java
Contents:
package ru.vsu.cs.platon.docs.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import ru.vsu.cs.platon.docs.model.Document;
import ru.vsu.cs.platon.docs.model.DocumentAccessLevel;
import ru.vsu.cs.platon.docs.model.User;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

public interface DocumentRepository extends JpaRepository<Document, UUID> {

    // Find all documents owned by a specific user
    List<Document> findByOwner(User owner);

    Page<Document> findByOwner(User owner, Pageable pageable);

    // Find document by title
    Optional<Document> findByTitle(String title);

    // Find documents accessible by public access level (READ_ONLY or EDITABLE)
    List<Document> findByAccessLevelIn(List<DocumentAccessLevel> accessLevels);
}

--------------------------------------------------
Path: ./main/java/ru/vsu/cs/platon/docs/repository/RefreshTokenRepository.java
Contents:
package ru.vsu.cs.platon.docs.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import ru.vsu.cs.platon.docs.model.RefreshToken;

import java.util.Optional;

public interface RefreshTokenRepository extends JpaRepository<RefreshToken, Long> {
    Optional<RefreshToken> findByToken(String token);  // Найти токен по значению
    void deleteByUserId(Long userId);  // Удалить все токены для пользователя
}

--------------------------------------------------
Path: ./main/java/ru/vsu/cs/platon/docs/repository/DocumentPermissionRepository.java
Contents:
package ru.vsu.cs.platon.docs.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import ru.vsu.cs.platon.docs.model.Document;
import ru.vsu.cs.platon.docs.model.DocumentPermission;
import ru.vsu.cs.platon.docs.model.User;

import java.util.List;
import java.util.Optional;

public interface DocumentPermissionRepository extends JpaRepository<DocumentPermission, Long> {

    // Find permissions for a specific document
    List<DocumentPermission> findByDocument(Document document);

    // Find permissions for a specific user
    List<DocumentPermission> findByUser(User user);

    // Find a specific permission by document and user
    Optional<DocumentPermission> findByDocumentAndUser(Document document, User user);
}

--------------------------------------------------
Path: ./main/java/ru/vsu/cs/platon/docs/repository/DocumentFileRepository.java
Contents:
package ru.vsu.cs.platon.docs.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import ru.vsu.cs.platon.docs.model.Document;
import ru.vsu.cs.platon.docs.model.DocumentFile;

import java.util.List;

public interface DocumentFileRepository extends JpaRepository<DocumentFile, Long> {

    // Find all files attached to a specific document
    List<DocumentFile> findByDocument(Document document);
}

--------------------------------------------------
Path: ./main/java/ru/vsu/cs/platon/docs/repository/UserRepository.java
Contents:
package ru.vsu.cs.platon.docs.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import ru.vsu.cs.platon.docs.model.User;

import java.util.Optional;

public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByEmail(String email);
    Optional<User> findByUsername(String username);
}

--------------------------------------------------
Path: ./main/java/ru/vsu/cs/platon/docs/config/SecurityConfig.java
Contents:
package ru.vsu.cs.platon.docs.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class SecurityConfig {
    private final JwtAuthenticationFilter jwtAuthenticationFilter;

    public SecurityConfig(JwtAuthenticationFilter jwtAuthenticationFilter) {
        this.jwtAuthenticationFilter = jwtAuthenticationFilter;
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        String[] patterns = new String[]{"/auth/**", "/swagger-ui/**", "/v3/api-docs/**", "/docs/**", "/openapi.json/**"};
        http
                .csrf(AbstractHttpConfigurer::disable)
                .sessionManagement(AbstractHttpConfigurer::disable)
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers(patterns).permitAll()  // Разрешаем публичные эндпоинты
                        .anyRequest().authenticated()                // Всё остальное требует авторизации
                )
                .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);  // JWT фильтр перед UsernamePassword

        // Добавляем JWT фильтр
// Отключаем сессии для JWT
        return http.build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}

--------------------------------------------------
Path: ./main/java/ru/vsu/cs/platon/docs/config/OpenApiConfig.java
Contents:
package ru.vsu.cs.platon.docs.config;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.security.SecurityRequirement;
import io.swagger.v3.oas.models.security.SecurityScheme;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class OpenApiConfig {

    @Bean
    public OpenAPI customOpenAPI() {
        final String securitySchemeName = "bearerAuth";

        return new OpenAPI()
                .info(new Info()
                        .title("User Management API")
                        .description("API for managing users with JWT authorization")
                        .version("1.0"))
                .addSecurityItem(new SecurityRequirement().addList(securitySchemeName))  // Добавляем замочек ко всем эндпоинтам
                .components(new io.swagger.v3.oas.models.Components()
                        .addSecuritySchemes(securitySchemeName, new SecurityScheme()
                                .name(securitySchemeName)
                                .type(SecurityScheme.Type.HTTP)
                                .scheme("bearer")
                                .bearerFormat("JWT")  // Указываем, что это JWT токен
                        ));
    }
}

--------------------------------------------------
Path: ./main/java/ru/vsu/cs/platon/docs/config/GlobalExceptionHandler.java
Contents:
package ru.vsu.cs.platon.docs.config;

import io.swagger.v3.oas.annotations.Hidden;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.server.ResponseStatusException;

import java.util.HashMap;
import java.util.Map;

@ControllerAdvice
@Hidden
public class GlobalExceptionHandler {

    @ExceptionHandler(ResponseStatusException.class)
    public ResponseEntity<Map<String, String>> handleResponseStatusException(ResponseStatusException ex) {
        Map<String, String> errorResponse = new HashMap<>();
        errorResponse.put("details", ex.getReason());
        return new ResponseEntity<>(errorResponse, ex.getStatusCode());
    }

    // Другие обработчики ошибок можно добавить здесь
}

--------------------------------------------------
Path: ./main/java/ru/vsu/cs/platon/docs/config/JwtAuthenticationFilter.java
Contents:
package ru.vsu.cs.platon.docs.config;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;
import ru.vsu.cs.platon.docs.model.User;
import ru.vsu.cs.platon.docs.repository.UserRepository;
import ru.vsu.cs.platon.docs.service.JwtService;

import java.io.IOException;
import java.util.Optional;

@Component
@RequiredArgsConstructor
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtService jwtService;
    private final UserRepository userRepository;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        String requestPath = request.getRequestURI();
        // Пропускаем фильтрацию для публичных эндпоинтов
        if (requestPath.startsWith("/auth/") ||
                requestPath.startsWith("/swagger-ui/") ||
                requestPath.startsWith("/v3/api-docs/") ||
                requestPath.startsWith("/docs/") ||
                requestPath.startsWith("/openapi.json")) {
            filterChain.doFilter(request, response);
            return;
        }


        String authHeader = request.getHeader("Authorization");
        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            filterChain.doFilter(request, response);
            return;
        }

        String jwt = authHeader.substring(7);
        String userEmail = jwtService.extractEmail(jwt);

        if (userEmail != null && SecurityContextHolder.getContext().getAuthentication() == null) {
            Optional<User> userDetails = userRepository.findByEmail(userEmail);
            if (userDetails.isPresent() && jwtService.isTokenValid(jwt)) {
                UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(
                        userDetails.get(), null, userDetails.get().getAuthorities());
                authenticationToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));

                SecurityContextHolder.getContext().setAuthentication(authenticationToken);
            }
        }

        filterChain.doFilter(request, response);
    }
}

--------------------------------------------------
Path: ./main/java/ru/vsu/cs/platon/docs/mapper/DocumentMapper.java
Contents:
package ru.vsu.cs.platon.docs.mapper;

import ru.vsu.cs.platon.docs.dto.DocumentDTO;
import ru.vsu.cs.platon.docs.model.Document;

public class DocumentMapper {

    public static DocumentDTO toDocumentDTO(Document document) {
        return new DocumentDTO(
                document.getId(),
                document.getTitle(),
                document.getCreatedAt().toString()
        );
    }
}

--------------------------------------------------
Path: ./main/java/ru/vsu/cs/platon/docs/mapper/DocumentPermissionMapper.java
Contents:
package ru.vsu.cs.platon.docs.mapper;

import ru.vsu.cs.platon.docs.dto.DocumentPermissionDTO;
import ru.vsu.cs.platon.docs.model.DocumentPermission;

public class DocumentPermissionMapper {
    public static DocumentPermissionDTO toDTO(DocumentPermission permission) {
        return new DocumentPermissionDTO(
                permission.getId(),
                permission.getUser().getId(),
                permission.getUser().getUsername(),
                permission.getRole()
        );
    }
}

--------------------------------------------------
Path: ./main/java/ru/vsu/cs/platon/docs/mapper/UserMapper.java
Contents:
package ru.vsu.cs.platon.docs.mapper;

import ru.vsu.cs.platon.docs.dto.UserDTO;
import ru.vsu.cs.platon.docs.dto.DocumentDTO;
import ru.vsu.cs.platon.docs.model.User;
import ru.vsu.cs.platon.docs.model.Document;

import java.util.List;
import java.util.stream.Collectors;

public class UserMapper {

    public static UserDTO toUserDTO(User user) {
        return new UserDTO(
                user.getId(),
                user.getEmail(),
                user.getUsername(),
                user.getRole(),
                null // Documents are not included by default
        );
    }

    public static UserDTO toUserDTOWithDocuments(User user) {
        List<DocumentDTO> documents = user.getDocuments()
                .stream()
                .limit(10)
                .map(DocumentMapper::toDocumentDTO)
                .collect(Collectors.toList());

        return new UserDTO(
                user.getId(),
                user.getEmail(),
                user.getUsername(),
                user.getRole(),
                documents
        );
    }
}
--------------------------------------------------
Path: ./main/java/ru/vsu/cs/platon/docs/controller/DocumentController.java
Contents:
package ru.vsu.cs.platon.docs.controller;

import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.server.ResponseStatusException;
import ru.vsu.cs.platon.docs.dto.*;
import ru.vsu.cs.platon.docs.mapper.DocumentMapper;
import ru.vsu.cs.platon.docs.mapper.DocumentPermissionMapper;
import ru.vsu.cs.platon.docs.model.Document;
import ru.vsu.cs.platon.docs.model.DocumentRole;
import ru.vsu.cs.platon.docs.model.User;
import ru.vsu.cs.platon.docs.repository.UserRepository;
import ru.vsu.cs.platon.docs.service.DocumentPermissionService;
import ru.vsu.cs.platon.docs.service.DocumentService;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import static org.springframework.http.HttpStatus.NOT_FOUND;

@RestController
@RequestMapping("/api/documents")
@RequiredArgsConstructor
public class DocumentController {

    private final DocumentService documentService;
    private final DocumentPermissionService permissionService;
    private final UserRepository userRepository;

    // Список документов владельца с пагинацией
    @GetMapping("/me")
    public ResponseEntity<List<DocumentDTO>> listDocuments(@AuthenticationPrincipal UserDetails userDetails,
                                                           @RequestParam(defaultValue = "0") int page,
                                                           @RequestParam(defaultValue = "10") int size) {
        User owner = userRepository.findByEmail(userDetails.getUsername())
                .orElseThrow(() -> new ResponseStatusException(NOT_FOUND, "User not found"));

        Page<Document> documents = documentService.getDocumentsByOwner(owner, PageRequest.of(page, size));
        List<DocumentDTO> documentDTOs = documents.stream()
                .map(DocumentMapper::toDocumentDTO)
                .collect(Collectors.toList());

        return ResponseEntity.ok(documentDTOs);
    }

    // Создать документ
    @PostMapping
    public ResponseEntity<DocumentDTO> createDocument(@AuthenticationPrincipal UserDetails userDetails,
                                                      @RequestBody CreateDocumentRequestDTO request) {
        User owner = userRepository.findByEmail(userDetails.getUsername())
                .orElseThrow(() -> new ResponseStatusException(NOT_FOUND, "User not found"));

        Document document = documentService.createDocument(owner, request.getTitle());
        return ResponseEntity.ok(DocumentMapper.toDocumentDTO(document));
    }

    private Document getDocumentForOwner(UserDetails userDetails, UUID documentId) {
        User owner = userRepository.findByEmail(userDetails.getUsername())
                .orElseThrow(() -> new ResponseStatusException(NOT_FOUND, "User not found"));

        Document document = documentService.findByIdAndOwner(documentId, owner)
                .orElseThrow(() -> new ResponseStatusException(NOT_FOUND, "Document not found"));

        if (!document.getOwner().getId().equals(owner.getId())) {
            throw new SecurityException("You do not have permission to perform this action.");
        }

        return document;
    }

    @PostMapping("/{documentId}/share")
    public ResponseEntity<?> shareDocument(@AuthenticationPrincipal UserDetails userDetails,
                                           @PathVariable UUID documentId,
                                           @RequestBody ShareDocumentRequestDTO request) {

        Document document = getDocumentForOwner(userDetails, documentId);
        permissionService.shareDocument(document, request.getEmail(), request.getRole());

        return ResponseEntity.ok("Document shared successfully");
    }

    @GetMapping("/{documentId}/permissions")
    public ResponseEntity<List<DocumentPermissionDTO>> viewPermissions(@AuthenticationPrincipal UserDetails userDetails,
                                                                       @PathVariable UUID documentId) {

        Document document = getDocumentForOwner(userDetails, documentId);

        List<DocumentPermissionDTO> permissions = permissionService.getPermissionsForDocument(document)
                .stream()
                .map(DocumentPermissionMapper::toDTO)
                .collect(Collectors.toList());

        return ResponseEntity.ok(permissions);
    }

    @PutMapping("/{documentId}")
    public ResponseEntity<DocumentDTO> updateDocument(@AuthenticationPrincipal UserDetails userDetails,
                                                      @PathVariable UUID documentId,
                                                      @RequestBody UpdateDocumentRequestDTO request) {

        Document document = getDocumentForOwner(userDetails, documentId);
        Document updatedDocument = documentService.updateDocument(document, request.getTitle(), request.getAccessLevel());

        return ResponseEntity.ok(DocumentMapper.toDocumentDTO(updatedDocument));
    }

    @DeleteMapping("/{documentId}/permissions/{email}")
    public ResponseEntity<?> removePermission(@AuthenticationPrincipal UserDetails userDetails,
                                              @PathVariable UUID documentId,
                                              @PathVariable String email) {

        Document document = getDocumentForOwner(userDetails, documentId);
        permissionService.removePermission(document, email);

        return ResponseEntity.ok("Permission removed successfully");
    }
}

--------------------------------------------------
Path: ./main/java/ru/vsu/cs/platon/docs/controller/AuthController.java
Contents:
package ru.vsu.cs.platon.docs.controller;

import jakarta.servlet.http.HttpServletRequest;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.web.bind.annotation.*;
import ru.vsu.cs.platon.docs.dto.auth.RegisterRequestDTO;
import ru.vsu.cs.platon.docs.dto.auth.LoginRequestDTO;
import ru.vsu.cs.platon.docs.dto.auth.RefreshRequestDTO;
import ru.vsu.cs.platon.docs.dto.auth.AuthResponseDTO;
import ru.vsu.cs.platon.docs.model.User;
import ru.vsu.cs.platon.docs.model.RefreshToken;
import ru.vsu.cs.platon.docs.model.UserRole;
import ru.vsu.cs.platon.docs.repository.UserRepository;
import ru.vsu.cs.platon.docs.service.JwtService;
import ru.vsu.cs.platon.docs.service.RefreshTokenService;

import java.util.Optional;

@RestController
@RequestMapping("/auth")
@RequiredArgsConstructor
@Slf4j
public class AuthController {

    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    private final JwtService jwtService;
    private final RefreshTokenService refreshTokenService;

    // === РЕГИСТРАЦИЯ ===
    @PostMapping("/register")
    public ResponseEntity<?> register(@RequestBody RegisterRequestDTO request) {
        if (userRepository.findByEmail(request.getEmail()).isPresent()) {
            return ResponseEntity.badRequest().body("User with this email already exists");
        }

        User newUser = User.builder()
                .email(request.getEmail())
                .username(request.getUsername())
                .passwordHash(passwordEncoder.encode(request.getPassword()))
                .role(UserRole.ROLE_USER)
                .build();

        userRepository.save(newUser);
        return ResponseEntity.ok("User registered successfully");
    }

    // === ЛОГИН ===
    @PostMapping("/login")
    public ResponseEntity<AuthResponseDTO> login(@RequestBody LoginRequestDTO request, HttpServletRequest httpRequest) {
        Optional<User> userOpt = userRepository.findByEmail(request.getEmail());
        if (userOpt.isEmpty() || !passwordEncoder.matches(request.getPassword(), userOpt.get().getPasswordHash())) {
            return ResponseEntity.status(401).build();
        }

        User user = userOpt.get();
        String accessToken = jwtService.generateAccessToken(user.getEmail());
        RefreshToken refreshToken = refreshTokenService.createRefreshToken(user, httpRequest);

        return ResponseEntity.ok(new AuthResponseDTO(accessToken, refreshToken.getToken()));
    }

    // === ОБНОВЛЕНИЕ ТОКЕНА ===
    @PostMapping("/refresh")
    public ResponseEntity<AuthResponseDTO> refresh(@RequestBody RefreshRequestDTO request, HttpServletRequest httpRequest) {
        Optional<RefreshToken> refreshTokenOpt = refreshTokenService.findByToken(request.getRefreshToken());

        if (refreshTokenOpt.isEmpty()) {
            return ResponseEntity.status(401).build();
        }

        RefreshToken refreshToken = refreshTokenOpt.get();

        if (refreshTokenService.isTokenExpired(refreshToken)) {
            refreshTokenService.deleteToken(refreshToken);
            return ResponseEntity.status(401).build();
        }

        refreshTokenService.deleteToken(refreshToken);
        RefreshToken newRefreshToken = refreshTokenService.createRefreshToken(refreshToken.getUser(), httpRequest);
        String newAccessToken = jwtService.generateAccessToken(refreshToken.getUser().getEmail());

        return ResponseEntity.ok(new AuthResponseDTO(newAccessToken, newRefreshToken.getToken()));
    }
}

--------------------------------------------------
Path: ./main/java/ru/vsu/cs/platon/docs/controller/UserController.java
Contents:
package ru.vsu.cs.platon.docs.controller;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import ru.vsu.cs.platon.docs.dto.UserDTO;
import ru.vsu.cs.platon.docs.mapper.UserMapper;
import ru.vsu.cs.platon.docs.model.User;
import ru.vsu.cs.platon.docs.repository.UserRepository;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/users")
@Tag(name = "Пользователи", description = "Операции для управления пользователями")
@RequiredArgsConstructor
@Slf4j
public class UserController {
    Logger logger = LoggerFactory.getLogger(UserController.class);

    private final UserRepository userRepository;

    @GetMapping("/me")
    @Operation(summary = "Получить информацию о текущем пользователе", description = "Возвращает данные текущего авторизованного пользователя")
    public ResponseEntity<UserDTO> getCurrentUser(@AuthenticationPrincipal UserDetails userDetails) {
        logger.info(userDetails.getUsername());
        Optional<User> userOptional = userRepository.findByEmail(userDetails.getUsername());

        return userOptional
                .map(user -> ResponseEntity.ok(UserMapper.toUserDTOWithDocuments(user)))
                .orElseGet(() -> ResponseEntity.notFound().build());
    }

    @GetMapping
    @PreAuthorize("hasRole('ROLE_ADMIN')")
    @Operation(summary = "Получить всех пользователей", description = "Возвращает список всех зарегистрированных пользователей (только для ADMIN)")
    public List<UserDTO> getAllUsers() {
        return userRepository.findAll()
                .stream()
                .map(UserMapper::toUserDTO)
                .collect(Collectors.toList());
    }

    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ROLE_ADMIN')")
    @Operation(summary = "Получить пользователя по ID", description = "Возвращает пользователя по его идентификатору (только для ADMIN)")
    public ResponseEntity<UserDTO> getUserById(@PathVariable Long id) {
        return userRepository.findById(id)
                .map(user -> ResponseEntity.ok(UserMapper.toUserDTO(user)))
                .orElseGet(() -> ResponseEntity.notFound().build());
    }
}

--------------------------------------------------
Path: ./main/java/ru/vsu/cs/platon/docs/model/RefreshToken.java
Contents:
package ru.vsu.cs.platon.docs.model;

import com.fasterxml.jackson.annotation.JsonBackReference;
import jakarta.persistence.*;
import lombok.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "refresh_tokens")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class RefreshToken {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    @JsonBackReference
    private User user;

    @Column(nullable = false, unique = true, length = 512)
    private String token;

    @Column(name = "expiry_date", nullable = false)
    private LocalDateTime expiryDate;

    @Column(name = "ip_address", length = 45)
    private String ipAddress;  // Хранение IP-адреса

    @Column(name = "user_agent", columnDefinition = "TEXT")
    private String userAgent;  // Хранение информации об устройстве

    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
}

--------------------------------------------------
Path: ./main/java/ru/vsu/cs/platon/docs/model/UserRole.java
Contents:
package ru.vsu.cs.platon.docs.model;

public enum UserRole {
    ROLE_USER,
    ROLE_ADMIN
}
--------------------------------------------------
Path: ./main/java/ru/vsu/cs/platon/docs/model/DocumentRole.java
Contents:
package ru.vsu.cs.platon.docs.model;

public enum DocumentRole {
    READER,   // Can only read
    EDITOR    // Can edit
}

--------------------------------------------------
Path: ./main/java/ru/vsu/cs/platon/docs/model/DocumentAccessLevel.java
Contents:
package ru.vsu.cs.platon.docs.model;

public enum DocumentAccessLevel {
    PRIVATE,
    READ_ONLY,
    EDITABLE
}

--------------------------------------------------
Path: ./main/java/ru/vsu/cs/platon/docs/model/DocumentFile.java
Contents:
package ru.vsu.cs.platon.docs.model;

import jakarta.persistence.*;
import lombok.*;

import java.time.LocalDateTime;

@Entity
@Table(name = "document_files")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class DocumentFile {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "document_id", nullable = false)
    private Document document;

    @Column(nullable = false)
    private String filePath; // Path to the file (image, attachment)

    @Column(nullable = false, updatable = false)
    private LocalDateTime uploadedAt;

    @PrePersist
    protected void onCreate() {
        uploadedAt = LocalDateTime.now();
    }
}

--------------------------------------------------
Path: ./main/java/ru/vsu/cs/platon/docs/model/DocumentPermission.java
Contents:
package ru.vsu.cs.platon.docs.model;

import jakarta.persistence.*;
import lombok.*;

import java.time.LocalDateTime;
import java.util.UUID;

@Entity
@Table(name = "document_permissions", uniqueConstraints = @UniqueConstraint(columnNames = {"document_id", "user_id"}))
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class DocumentPermission {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "document_id", nullable = false)
    private Document document;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private DocumentRole role;

    @Column(nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @Column(nullable = false)
    private LocalDateTime updatedAt;

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
}

--------------------------------------------------
Path: ./main/java/ru/vsu/cs/platon/docs/model/User.java
Contents:
package ru.vsu.cs.platon.docs.model;

import com.fasterxml.jackson.annotation.JsonManagedReference;
import jakarta.persistence.*;
import lombok.*;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.time.LocalDateTime;
import java.util.Collection;
import java.util.Collections;
import java.util.List;

@Entity
@Table(name = "users")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class User implements UserDetails {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true)
    private String email;

    @Column(name = "password_hash", nullable = false)
    private String passwordHash;

    @Column(nullable = false)
    private String username;

    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;

    @Enumerated(EnumType.STRING)
    @Column(name = "role", nullable = false)
    @Getter
    private UserRole role;

    // Перед сохранением автоматически задаем время создания и обновления
    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }

    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
    @JsonManagedReference
    private List<RefreshToken> refreshTokens;

    @OneToMany(mappedBy = "owner", cascade = CascadeType.ALL, orphanRemoval = true)
    @JsonManagedReference
    private List<Document> documents;

    // Реализация методов UserDetails для Spring Security
    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return Collections.singleton(() -> role.name());
    }

    @Override
    public String getPassword() {
        return passwordHash;
    }

    @Override
    public String getUsername() {
        return email;
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return true;
    }
}

--------------------------------------------------
Path: ./main/java/ru/vsu/cs/platon/docs/model/Document.java
Contents:
package ru.vsu.cs.platon.docs.model;

import com.fasterxml.jackson.annotation.JsonBackReference;
import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.GenericGenerator;

import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

@Entity
@Table(name = "documents")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Document {

    @Id
    @GeneratedValue(generator = "UUID")
    @GenericGenerator(name = "UUID", strategy = "org.hibernate.id.UUIDGenerator")
    @Column(name = "id", updatable = false, nullable = false)
    private UUID id;

    @Column(nullable = false)
    private String title;

    @Column(nullable = false)
    private String filePath;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "owner_id", nullable = false)
    @JsonBackReference
    private User owner;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    @Builder.Default
    private DocumentAccessLevel accessLevel = DocumentAccessLevel.PRIVATE;

    @Column(nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @Column(nullable = false)
    private LocalDateTime updatedAt;

    @OneToMany(mappedBy = "document", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<DocumentPermission> permissions;

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
}
--------------------------------------------------
Path: ./main/java/ru/vsu/cs/platon/docs/service/JwtService.java
Contents:
package ru.vsu.cs.platon.docs.service;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.util.Date;
import java.util.function.Function;

@Service
public class JwtService {

    @Value("${jwt.secret}")
    private String jwtSecret;

    // Генерация Access токена
    public String generateAccessToken(String email) {
        // Access Token живёт 15 минут
        long accessTokenValidity = 1000 * 60 * 15;
        return createToken(email, accessTokenValidity);
    }

    // Создание JWT токена
    private String createToken(String subject, long validity) {
        return Jwts.builder()
                .setSubject(subject)
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + validity))
                .signWith(SignatureAlgorithm.HS256, jwtSecret)
                .compact();
    }

    // Проверка валидности токена
    public boolean isTokenValid(String token) {
        try {
            return !isTokenExpired(token);
        } catch (Exception e) {
            return false;
        }
    }

    // Проверка на истечение срока действия токена
    private boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }

    // Извлечение срока действия токена
    public Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }

    // Извлечение Email (subject) из токена
    public String extractEmail(String token) {
        return extractClaim(token, Claims::getSubject);
    }

    // Универсальный метод извлечения данных из токена
    public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }

    // Извлечение всех данных из токена
    private Claims extractAllClaims(String token) {
        return Jwts.parser()
                .setSigningKey(jwtSecret)
                .parseClaimsJws(token)
                .getBody();
    }
}

--------------------------------------------------
Path: ./main/java/ru/vsu/cs/platon/docs/service/DocumentService.java
Contents:
package ru.vsu.cs.platon.docs.service;

import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import ru.vsu.cs.platon.docs.model.Document;
import ru.vsu.cs.platon.docs.model.DocumentAccessLevel;
import ru.vsu.cs.platon.docs.model.User;
import ru.vsu.cs.platon.docs.repository.DocumentRepository;

import java.util.Optional;
import java.util.UUID;

@Service
@RequiredArgsConstructor
public class DocumentService {

    private final DocumentRepository documentRepository;

    // Получить все документы владельца с пагинацией
    public Page<Document> getDocumentsByOwner(User owner, Pageable pageable) {
        return documentRepository.findByOwner(owner, pageable);
    }

    // Создать документ
    public Document createDocument(User owner, String title) {
        Document document = Document.builder()
                .title(title)
                .owner(owner)
                .filePath("path/to/encrypted/file.md")
                .build();
        return documentRepository.save(document);
    }

    // Найти документ по ID и владельцу
    public Optional<Document> findByIdAndOwner(UUID documentId, User owner) {
        return documentRepository.findById(documentId)
                .filter(doc -> doc.getOwner().equals(owner));
    }

    // Обновить документ
    public Document updateDocument(Document document, String title, DocumentAccessLevel accessLevel) {
        document.setTitle(title);
        document.setAccessLevel(accessLevel);
        return documentRepository.save(document);
    }
}

--------------------------------------------------
Path: ./main/java/ru/vsu/cs/platon/docs/service/RefreshTokenService.java
Contents:
package ru.vsu.cs.platon.docs.service;

import jakarta.servlet.http.HttpServletRequest;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import ru.vsu.cs.platon.docs.model.RefreshToken;
import ru.vsu.cs.platon.docs.model.User;
import ru.vsu.cs.platon.docs.repository.RefreshTokenRepository;

import java.time.LocalDateTime;
import java.util.Optional;
import java.util.UUID;

@Service
@RequiredArgsConstructor
public class RefreshTokenService {

    private final RefreshTokenRepository refreshTokenRepository;

    private final long refreshTokenDurationDays = 7;  // Жизнь токена - 7 дней

    // Генерация токена
    public RefreshToken createRefreshToken(User user, HttpServletRequest request) {
        String ipAddress = request.getRemoteAddr();
        String userAgent = request.getHeader("User-Agent");

        RefreshToken refreshToken = RefreshToken.builder()
                .user(user)
                .token(UUID.randomUUID().toString())
                .expiryDate(LocalDateTime.now().plusDays(refreshTokenDurationDays))
                .ipAddress(ipAddress)
                .userAgent(userAgent)
                .build();

        return refreshTokenRepository.save(refreshToken);
    }

    // Поиск токена по его значению
    public Optional<RefreshToken> findByToken(String token) {
        return refreshTokenRepository.findByToken(token);
    }

    // Проверка токена на валидность
    public boolean isTokenExpired(RefreshToken token) {
        return token.getExpiryDate().isBefore(LocalDateTime.now());
    }

    // Удаление токена по объекту токена
    public void deleteToken(RefreshToken token) {
        refreshTokenRepository.delete(token);
    }

    // Удаление всех токенов пользователя (например, при выходе)
    public void deleteTokensForUser(User user) {
        refreshTokenRepository.deleteByUserId(user.getId());
    }

    // Обновление токена: удаление старого и создание нового
    public RefreshToken refreshToken(RefreshToken oldToken, HttpServletRequest request) {
        deleteToken(oldToken);
        return createRefreshToken(oldToken.getUser(), request);
    }
}

--------------------------------------------------
Path: ./main/java/ru/vsu/cs/platon/docs/service/DocumentPermissionService.java
Contents:
package ru.vsu.cs.platon.docs.service;

import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.web.server.ResponseStatusException;
import ru.vsu.cs.platon.docs.model.Document;
import ru.vsu.cs.platon.docs.model.DocumentPermission;
import ru.vsu.cs.platon.docs.model.DocumentRole;
import ru.vsu.cs.platon.docs.model.User;
import ru.vsu.cs.platon.docs.repository.DocumentPermissionRepository;
import ru.vsu.cs.platon.docs.repository.UserRepository;

import java.util.List;
import java.util.Optional;

@Service
@RequiredArgsConstructor
public class DocumentPermissionService {

    private final DocumentPermissionRepository permissionRepository;
    private final UserRepository userRepository;

    // Поделиться документом с другим пользователем
    public DocumentPermission shareDocument(Document document, String userEmail, DocumentRole role) {
        // Поиск пользователя по email
        User user = userRepository.findByEmail(userEmail)
                .orElseThrow(() -> new ResponseStatusException(
                        HttpStatus.NOT_FOUND, "User not found"
                ));

        // Проверка существующего разрешения
        Optional<DocumentPermission> existingPermissionOpt = permissionRepository.findByDocumentAndUser(document, user);

        if (existingPermissionOpt.isPresent()) {
            // Если разрешение уже существует, обновляем его роль
            DocumentPermission existingPermission = existingPermissionOpt.get();
            existingPermission.setRole(role);
            return permissionRepository.save(existingPermission);
        } else {
            // Если разрешения нет, создаем новое
            DocumentPermission newPermission = DocumentPermission.builder()
                    .document(document)
                    .user(user)
                    .role(role)
                    .build();
            return permissionRepository.save(newPermission);
        }
    }

    // Получить разрешения для документа
    public List<DocumentPermission> getPermissionsForDocument(Document document) {
        return permissionRepository.findByDocument(document);
    }

    // Изменить разрешение для пользователя
    public Optional<DocumentPermission> updatePermission(Document document, String userEmail, DocumentRole newRole) {
        User user = userRepository.findByEmail(userEmail)
                .orElseThrow(() -> new ResponseStatusException(
                        HttpStatus.NOT_FOUND, "User not found"
                ));

        Optional<DocumentPermission> permissionOpt = permissionRepository.findByDocumentAndUser(document, user);
        if (permissionOpt.isPresent()) {
            DocumentPermission permission = permissionOpt.get();
            permission.setRole(newRole);
            permissionRepository.save(permission);
        }
        return permissionOpt;
    }

    // Удалить разрешение
    public void removePermission(Document document, String userEmail) {
        User user = userRepository.findByEmail(userEmail)
                .orElseThrow(() -> new ResponseStatusException(
                        HttpStatus.NOT_FOUND, "User not found"
                ));

        permissionRepository.findByDocumentAndUser(document, user)
                .ifPresent(permissionRepository::delete);
    }
}

--------------------------------------------------
